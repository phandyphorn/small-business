{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shallowEqual = exports.assignUniqueKeysToParts = exports.DEFAULT_INTL_CONFIG = exports.invariantIntlContext = void 0;\nvar tslib_1 = require(\"tslib\");\nvar React = tslib_1.__importStar(require(\"react\"));\nvar ecma402_abstract_1 = require(\"@formatjs/ecma402-abstract\");\nvar intl_1 = require(\"@formatjs/intl\");\nfunction invariantIntlContext(intl) {\n  (0, ecma402_abstract_1.invariant)(intl, '[React Intl] Could not find required `intl` object. ' + '<IntlProvider> needs to exist in the component ancestry.');\n}\nexports.invariantIntlContext = invariantIntlContext;\nexports.DEFAULT_INTL_CONFIG = tslib_1.__assign(tslib_1.__assign({}, intl_1.DEFAULT_INTL_CONFIG), {\n  textComponent: React.Fragment\n});\n/**\n * Takes a `formatXMLElementFn`, and composes it in function, which passes\n * argument `parts` through, assigning unique key to each part, to prevent\n * \"Each child in a list should have a unique \"key\"\" React error.\n * @param formatXMLElementFn\n */\nfunction assignUniqueKeysToParts(formatXMLElementFn) {\n  return function (parts) {\n    // eslint-disable-next-line prefer-rest-params\n    return formatXMLElementFn(React.Children.toArray(parts));\n  };\n}\nexports.assignUniqueKeysToParts = assignUniqueKeysToParts;\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  if (!objA || !objB) {\n    return false;\n  }\n  var aKeys = Object.keys(objA);\n  var bKeys = Object.keys(objB);\n  var len = aKeys.length;\n  if (bKeys.length !== len) {\n    return false;\n  }\n  for (var i = 0; i < len; i++) {\n    var key = aKeys[i];\n    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.shallowEqual = shallowEqual;","map":{"version":3,"names":["Object","defineProperty","exports","value","shallowEqual","assignUniqueKeysToParts","DEFAULT_INTL_CONFIG","invariantIntlContext","tslib_1","require","React","__importStar","ecma402_abstract_1","intl_1","intl","invariant","__assign","textComponent","Fragment","formatXMLElementFn","parts","Children","toArray","objA","objB","aKeys","keys","bKeys","len","length","i","key","prototype","hasOwnProperty","call"],"sources":["/home/phandy/Documents/my-app/node_modules/react-intl/src/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shallowEqual = exports.assignUniqueKeysToParts = exports.DEFAULT_INTL_CONFIG = exports.invariantIntlContext = void 0;\nvar tslib_1 = require(\"tslib\");\nvar React = tslib_1.__importStar(require(\"react\"));\nvar ecma402_abstract_1 = require(\"@formatjs/ecma402-abstract\");\nvar intl_1 = require(\"@formatjs/intl\");\nfunction invariantIntlContext(intl) {\n    (0, ecma402_abstract_1.invariant)(intl, '[React Intl] Could not find required `intl` object. ' +\n        '<IntlProvider> needs to exist in the component ancestry.');\n}\nexports.invariantIntlContext = invariantIntlContext;\nexports.DEFAULT_INTL_CONFIG = tslib_1.__assign(tslib_1.__assign({}, intl_1.DEFAULT_INTL_CONFIG), { textComponent: React.Fragment });\n/**\n * Takes a `formatXMLElementFn`, and composes it in function, which passes\n * argument `parts` through, assigning unique key to each part, to prevent\n * \"Each child in a list should have a unique \"key\"\" React error.\n * @param formatXMLElementFn\n */\nfunction assignUniqueKeysToParts(formatXMLElementFn) {\n    return function (parts) {\n        // eslint-disable-next-line prefer-rest-params\n        return formatXMLElementFn(React.Children.toArray(parts));\n    };\n}\nexports.assignUniqueKeysToParts = assignUniqueKeysToParts;\nfunction shallowEqual(objA, objB) {\n    if (objA === objB) {\n        return true;\n    }\n    if (!objA || !objB) {\n        return false;\n    }\n    var aKeys = Object.keys(objA);\n    var bKeys = Object.keys(objB);\n    var len = aKeys.length;\n    if (bKeys.length !== len) {\n        return false;\n    }\n    for (var i = 0; i < len; i++) {\n        var key = aKeys[i];\n        if (objA[key] !== objB[key] ||\n            !Object.prototype.hasOwnProperty.call(objB, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.shallowEqual = shallowEqual;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAGF,OAAO,CAACG,uBAAuB,GAAGH,OAAO,CAACI,mBAAmB,GAAGJ,OAAO,CAACK,oBAAoB,GAAG,KAAK,CAAC;AAC5H,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,IAAIC,KAAK,GAAGF,OAAO,CAACG,YAAY,CAACF,OAAO,CAAC,OAAO,CAAC,CAAC;AAClD,IAAIG,kBAAkB,GAAGH,OAAO,CAAC,4BAA4B,CAAC;AAC9D,IAAII,MAAM,GAAGJ,OAAO,CAAC,gBAAgB,CAAC;AACtC,SAASF,oBAAoBA,CAACO,IAAI,EAAE;EAChC,CAAC,CAAC,EAAEF,kBAAkB,CAACG,SAAS,EAAED,IAAI,EAAE,sDAAsD,GAC1F,0DAA0D,CAAC;AACnE;AACAZ,OAAO,CAACK,oBAAoB,GAAGA,oBAAoB;AACnDL,OAAO,CAACI,mBAAmB,GAAGE,OAAO,CAACQ,QAAQ,CAACR,OAAO,CAACQ,QAAQ,CAAC,CAAC,CAAC,EAAEH,MAAM,CAACP,mBAAmB,CAAC,EAAE;EAAEW,aAAa,EAAEP,KAAK,CAACQ;AAAS,CAAC,CAAC;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,uBAAuBA,CAACc,kBAAkB,EAAE;EACjD,OAAO,UAAUC,KAAK,EAAE;IACpB;IACA,OAAOD,kBAAkB,CAACT,KAAK,CAACW,QAAQ,CAACC,OAAO,CAACF,KAAK,CAAC,CAAC;EAC5D,CAAC;AACL;AACAlB,OAAO,CAACG,uBAAuB,GAAGA,uBAAuB;AACzD,SAASD,YAAYA,CAACmB,IAAI,EAAEC,IAAI,EAAE;EAC9B,IAAID,IAAI,KAAKC,IAAI,EAAE;IACf,OAAO,IAAI;EACf;EACA,IAAI,CAACD,IAAI,IAAI,CAACC,IAAI,EAAE;IAChB,OAAO,KAAK;EAChB;EACA,IAAIC,KAAK,GAAGzB,MAAM,CAAC0B,IAAI,CAACH,IAAI,CAAC;EAC7B,IAAII,KAAK,GAAG3B,MAAM,CAAC0B,IAAI,CAACF,IAAI,CAAC;EAC7B,IAAII,GAAG,GAAGH,KAAK,CAACI,MAAM;EACtB,IAAIF,KAAK,CAACE,MAAM,KAAKD,GAAG,EAAE;IACtB,OAAO,KAAK;EAChB;EACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IAC1B,IAAIC,GAAG,GAAGN,KAAK,CAACK,CAAC,CAAC;IAClB,IAAIP,IAAI,CAACQ,GAAG,CAAC,KAAKP,IAAI,CAACO,GAAG,CAAC,IACvB,CAAC/B,MAAM,CAACgC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACV,IAAI,EAAEO,GAAG,CAAC,EAAE;MAClD,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AACA7B,OAAO,CAACE,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}